{
  "name": "node-simple-router",
  "description": "Yet another minimalistic router for node.js",
  "tags": [
    "http",
    "simple",
    "routing",
    "router",
    "utils",
    "async",
    "promises"
  ],
  "keywords": [
    "http",
    "url",
    "websockets",
    "dispatch",
    "router",
    "request handler",
    "middleware",
    "async",
    "promises"
  ],
  "version": "0.9.1-1",
  "homepage": "http://node-simple-router.herokuapp.com",
  "author": {
    "name": "Ernesto Savoretti",
    "email": "esavoretti@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/sandy98/node-simple-router.git"
  },
  "bugs": {
    "url": "http://github.com/sandy98/node-simple-router/issues"
  },
  "engines": [
    "node >= 0.8"
  ],
  "devDependencies": {
    "coffee-script": "latest"
  },
  "main": "./lib/router.js",
  "bin": {
    "mk-server": "./bin/mk-server"
  },
  "scripts": {
    "nix_test": "if [ ! -f test/server.js ] || [ test/server.js -ot test/server.coffee ]; then scripts/compile_test.sh; fi && test/server.js",
    "nix_prepublish": "scripts/compile.sh",
    "test": "cake test",
    "prepublish": "cake build"
  },
  "readme": "# Node Simple Router <img src=\"https://raw.github.com/sandy98/node-simple-router/master/test/public/img/router50.png\" />\n### Yet another minimalistic router for node.js \n\n# Getting started\n\n## \n**Step 1: Install**\n\nFrom Node Package Manager:\n\n    npm install node-simple-router`</pre>\n\nFrom source:\n\n    git clone https://github.com/sandy98/node-simple-router\n\n\n## \n**Step 2: Test**\n\n    cd to your installation directory and run `npm test`\nthen point your browser to _http://localhost:8000_ and review the info\nand above all, try the examples.\n\n\n## \n**Step 3: Run your server**\n\nYou can roll your own, or use the sample server that NSR provides by means of the mk-server utility:\n\n`mk-server js` will provide a barebones server (_server.js_)  with some example routes ready to run.\n\nIn order for this to work, you must have installed NSR global, like so:\n\n   `sudo npm install -g node-simple-router`, or have the .bin directory of NSR in your path by whatever means you see fit.\n\nEither case, the basic steps are the same:\n\n#### Import 'http'\n\n`var http = require('http');`\n\n#### Import NSR\n\n`var Router = require('node-simple-router');`\n\n#### Instantiate the router\n\n`var router = Router(); // may also be router = new Router();`\n\n#### Add some routes\n\n`router.get(\"/hello\", function(request, response) {response.end(\"Hello, World!\"};});`\n\n#### Create an http server using router as the handler\n\n`var server = http.createServer(router);`\n\n#### Finally, make it listen on your chosen port and you're in business\n\n`server.listen(1234);`\n\n\n# Documents\n\n### Rationale\n\nRouting, in web app parlance, is about defining what code to execute when a given URL is invoked.\nNSR takes care of the necessary plumbing to make that happen,\nfreeing the programmer of the cumbersome details, allowing her to focus on the problem domain.\n#### How does it work?\nAs was stated in the lines above, it's not necessary to know <span class=\"nsr\">NSR</span>\ninner workings in order to be productive using it. Having said that, it is nevertheless useful to\nhave some insight on a couple of key aspects, fundamentally what could be called the <em>\"request wrapping\nmechanism\"</em>.\n\nWhen you feed <span class=\"nsr\">NSR</span> with a url handling function, i.e. <code class=\"js\">\nrouter.get(\"/answertoall\", function(request, response) {response.end(\"42\");});</code>\n\nwhat <span class=\"nsr\">NSR</span>\ndoes is to wrap that function into another, unnamed one, which has the primary mission of _\"augmenting\"_ the request\nobject and it stores said function in an array of url-handling functions, thus acting as a _middleware_ piece of code.\nAt run time, when a client invokes the matching URL, the \"middleware\" function will be called, which, after doing its trickery to \"dress\" the request object, will ultimately call the original url-handling function that was provided.\n            \nWhat does _\"augmenting-dressing\"_  the request object mean?\n\nWell, basically, <span class=\"nsr\">NSR</span> provides the request object with 3 properties:\n            <ul>\n              <li>**request.get** which is an object representation of the <dfn>query string</dfn></li>\n              <li>**request.post** an object representation of what was posted, if anything</li>\n              <li>**request.body** is the union of the two previous items</li>\n            </ul>\n            It should be pointed down that regardless the transmission method, <span class=\"nsr\">NSR</span>\n            takes the necessary steps to make all 3 of them true javascript objects with all that implies, JSON and all.\n            Worst case is an empty object **{}**, no errors.\n            So, you can use `request.get.whatever` for `router.get`,\n            `request.post.whatever` for `router.post`, but in any case, if you don't care about request method,\n            using `request.body.whatever` is a safe bet, most obviously useful if you do not know in advance\n            the request method, for example: <code class=\"js\">router.any(\"/threefold\", function(request, response)\n            {response.end((parseInt(request.body.number) * 3).toString();});</code>\n         </p>\n         <p>\n             Wrapping up, you just got to remember **request.get, request.post** and **request.body**\n             \nAnd that's all there is about it.\n\n### Options\n\nNSR sticks to some conventions (\"public\" as directory name for static assets, etc),\nwhich the programmer can override when instantiating the router, for instance:\n\n    var router = new Router({static_route: __dirname + \"/static\"});\nto change usage of the default \"public\" directory for static resources\n            \n\nList of default options:\n            <p>\n                <pre><code class=\"js\">\n                logging: true\n                log: console.log\n                static_route: \"#{process.cwd()}/public\"\n                serve_static: true\n                list_dir: true\n                default_home: ['index.html', 'index.htm', 'default.htm']\n                cgi_dir: \"cgi-bin\"\n                serve_cgi: true\n                serve_php: true\n                php_cgi: \"php-cgi\"\n                served_by: 'Node Simple Router'\n                software_name: 'node-simple-router'\n                admin_user: 'admin'\n                admin_pwd: 'admin'\n                use_nsr_session: true\n                avail_nsr_session_handlers: ['dispatch.memory_store', 'dispatch.text_store']\n                nsr_session_handler: 'dispatch.memory_store'\n                </code></pre>\n            </p>\n            <p>\n                Most of them are self explanatory, but some deserve further comments,\n                which will be added on doc completion.\n            </p>\n \n## Router API\n\nRouter object supports the following methods\n#### <dfn>get</dfn>\n_Usage:_\n\n      router.get('/users/:id', function(request, response) {\n        response.end(\"User: \" + getUserById(request.params.id).fullName);});\n          \n#### <dfn>post</dfn>\n_Usage:_\n\n    router.post('/users', function(request, response) {\n                        insertUser(request.post.user, function(new_user_id) {\n                          request.post.user.id = new_user_id;\n                          response.end(JSON.stringify(request.post.user);});\n                        });\n\n#### Handling file uploads\n<span class=\"nsr\">NSR</span> handles 'multipart/form-data' out of the box.\nWhen <span class=\"nsr\">NSR</span> detects a post having enctype=\"multipart/form-data\" it\nadds to the _request_ object the properties: <em>fileName, fileLen, fileData and\nfileType</em>, which client code (your server) can handle as shown in the following usage example.\n\n_Usage:_\n\n        router.post(\"/handle_upload\", function(request, response) {\n        var encoding, fullname;\n        response.writeHead(200, {'Content-type': 'text/html'});\n        if (request.fileName) {\n           response.write(\"&lt;h2&gt;Uploaded File Data&lt;/h2&g\");\n           response.write(\"File name = \" + request.fileName + \"&lt;br/&gt;\");\n           response.write(\"File length = \" + request.fileLen + \" bytes&lt;br/&gt;\");\n           response.write(\"File type = \" + request.fileType + \"&lt;br/&gt;\");\n           fullname = \"\" + __dirname + \"/public/uploads/\" + request.fileName;\n           if (request.fileType.indexOf('text') &gt;= 0) {\n              encoding = 'utf8';\n           }\n           else {\n             encoding = 'binary';\n           }\n           return fs.writeFile(fullname, request.fileData, {encoding: encoding}, function(err) {\n             if (err) {\n               response.write(\"&lt;p style='color: red;'&gt;Something went wrong, uploaded file could not be saved.&lt;/p&gt;\");\n             }\n             else {\n               response.write('&lt;div style=\"text-align:center; padding: 1em; border: 1px solid; border-radius: 5px;\"&gt;');\n               if (request.fileType.indexOf('image') &gt;= 0) {\n                 response.write(\"&lt;img src='/uploads/\" + request.fileName + \"' /&gt;\");\n               }\n               else {\n                 response.write(\"&lt;pre&gt;\" + request.fileData + \"&lt;/pre&gt;\");\n               }\n               response.write(\"&lt;/div&gt;\");\n             }\n             response.write(\"&lt;hr/&gt;\");\n             return response.end(\"&lt;div style=\\\"text-align: center;\\\"&gt;&lt;button onclick=\\\"history.back();\\\"&gt;Back&lt;/button&gt;&lt;/div&gt;\");\n           });\n         }\n         else {\n           response.write(\"&lt;p style='color: red;'&gt;Something went wrong, looks like nothing was uploaded.&lt;/p&gt;\");\n           return response.end(\"&lt;div style=\\\"text-align: center;\\\"&gt;&lt;button onclick=\\\"history.back();\\\"&gt;Back&lt;/button&gt;&lt;/div&gt;\");\n         }\n      });\n      \n#### <dfn>put</dfn>\n_Usage:_\n\n    router.put('/users', function(request, response) {\n        updateUser(request.post.user, function(updated_user_id) {\n        response.end(updated_user_id);})\n    });                use_nsr_session: true<br/>\n                avail_nsr_session_handlers: ['dispatch.memory_store', 'dispatch.text_store']<br/>\n                nsr_session_handler: 'dispatch.memory_store'<br/>\n\n\n#### <dfn>patch</dfn>\nA variant for PUT\n\n_Usage:_\n\n    router.patch('/users', function(request, response) {\n        updateUser(request.post.user, function(updated_user_id) {\n        response.end(updated_user_id);});\n    });\n\n#### <dfn>delete</dfn>\n\n_Usage:_\n\n    router.delete('/users', function(request, response) {\n        deleteUser(request.post.user_id, function(user_id) {\n        response.end(user_id);});\n    });\n\n#### <dfn>any</dfn>\nTo be used when the request method is not known in advance. Sort of \"catch all\"\n\n_Usage:_\n\n    // Observe usage of 'request.body' as the union of 'request.get' and 'request.post'\n    router.any('/users', function(request, response) {\n        response.end(\"User: \" + getUserById(request.body.user_id).fullName);}); \n\n\n### <dfn>Complementary methods</dfn>\n \nUp to here, all the enumerated methods are directly related to <span class=\"nsr\">NSR</span> primary activity: routing.\n\nThey are what you will use 90% of the time.\n\nWhat follows are method loosely related to routing activity, but are the ones that give <span class=\"nsr\">NSR</span> some of its distinctiveness.\n\n#### <dfn>proxy_pass</dfn>\n\nTo deliver to the client the contents of an url from another server\n\n_Usage:_\n\n    router.get('/whatismyip', function(request, response) {\n        router.proxy_pass('http://testing.savos.ods.org/wimi', response);});\n\n#### <dfn><abbr title=\"Common Gateway Interface\">cgi</abbr></dfn>\n\nTo pass the client the results of an external CGI program.\n\nThis one deserves an additional comment on its usefulness. While some - many perhaps - would argue that CGI doesn't make any sense from a Node.js development perspective, I still it's a worthy inclusion for a couple of reasons\n - First of all, you may have a legacy CGI module that you want/need to use in your brand new Node.js server - would you rewrite, for instance, Crafty, the chess engine, in Node?\n - Writing programs that can talk to each other through standard means (stdin, stdout) has passed the test of time, and I think it has it niche even in the web server world.\n - If performance is a concern - and it should be - the present considerations still stand for the next item: SCGI, which NSR also supports. But there would not have been SCGI without CGI\n - Last but not least, CGI support makes the same sense in the context of a Node.js web server thant it does in Nginx, Apache, etc.. I'm not aware of anybody suggestiong CGI support should be dropped from any of them.\n\n_Usage:_\n\n<samp>\n    By default, any static resource having a path that includes the router option 'cgi-dir'\n    (which defaults to \"cgi-bin\") will be treated by <span class=\"nsr\">NSR</span>\n    as a cgi program, provided the router option 'serve_cgi' is true.\n    For example, the uri: `/cgi-bin/hello.py` will be handled as a CGI program.\n    On the other hand, you can invoke directly the cgi method of the router, like so:\n    `router.cgi('/hidden-cgi-dir/mycgi.rb', request, response);`\n    Nevertheless, such way of using it is discouraged as it does not follow CGI standard\n    guidelines.\n</samp>\n\n#### <dfn>scgi_pass</dfn>\n                            \n\nTo pass the client the results of an external program running under the [SCGI](http://en.wikipedia.org/wiki/SCGI) protocol.\n\nSame considerations as those pertaining to CGI, with the added benefit of not having to spawn a new process each time.\n\nWhy SCGI and not <dfn title=\"Fast CGI\">FCGI</dfn>? Well, SCGI protocol was far easier to implement, and I really couldn't find significant performance differences between the two. FCGI may be implenented in future versions.\n\n_Usage:_\n\n    //Example SCGI invocation. Output will be provided by a SCGI process listening on tcp port 26000.\n    router.post(\"/scgi\", function(request, response) {\n      router.scgi_pass(26000, request, response);\n    });\n\nThe first parameter for scgi_pass is the port number (for tcp sockets)\nor the socket name (for unix sockets) at which the SCGI process is listening.\n\n#### <dfn>render_template</dfn>\n                            \n\nTo provide rudimentary template handling without compromising the goal of keeping <span class=\"nsr\">NSR</span> lean and simple.\n\nEven though templating is not directly related to routing, having a micro-templating utility was considered handy.\n\nIt is basically a naive implementation of [mustache.js](http://mustache.github.io/), which tries to follow the [spec](http://mustache.github.io/mustache.5.html), but at its current stage lacks partials and lambdas. Template handling as you would with any mustache template, as shown in the following example.\n\n_Usage:_\n\n    router.get(\"/greet_user/:user_id\", function(request, response) {\n      get_user_by_id(request.params.user_id, function (user) {\n        template_str = \"&lt;h2&gt;Hello, {{ name }}!&lt;h2&gt;\";\n        compiled_str = router.render_template(template_str, user); // returns \"&lt;h2&gt;Hello, Joe Router!&lt;h2&gt;\"\n        response.end(compiled_str);\n      }\n    });\n\nNew in version 0.8.8: `render_template_file(fileName, context, callback, keep_tokens)` was added\nThe method signature is almost the same than for **render_template** with 2 differences worth noting\n\n* The first parameter is a string containing the file name, not the template string itself.\n\n* There is a new parameter, previous to last one: a callback function with the following signature:\n`cb(exists, rendered_text);`. The reason for this is that obviously file retrieval is an async IO  operation and as such it needs a callback, which **render_template** doesn't need as there is no IO involved.\n                                \nObviously it would have been better to keep only one method (**render_template**), letting it guess if the first parameter is  a file name or a template string, but doing it that way would introduce a backward incompatibility since **render_template** returns a string, while becoming async would make it need a callback. So... too late to regret. It's not big deal, anyway..\n\n\n#### <dfn>Session handling</dfn>\n\n\nThis section deals with session handling utilities built in with NSR.\n\n<p>\n    <span class=\"nsr\">NSR</span> augments the request object with a <em>nsr_session</em> object\n    unless the option <em>use_nsr_session</em> is set to a falsy value (defaults to true).<br/>\n    <strong><em>nsr_session</em></strong> is a javascript object that holds the session keys and values\n    defined by the application. Incidentally, the reason <span class=\"nsr\">NSR</span> uses\n    <em>request.nsr_session</em> and not <em>request.session</em> is to avoid name collision in case\n    that a separate session handling mechanism is used.\n</p>\n\n<p>\n    Options related to session handling:\n    <ul style=\"list-style-type: none;\">\n       <li><strong>use_nsr_session</strong> Set <em>nsr_session</em> on or off</li>\n       <li><strong>avail_nsr_session_handlers</strong> Low level functions that perform the real action. See below for details</li>\n       <li><strong>nsr_session_handler</strong> The one handler currently selected</li>\n    </ul>\n</p>\n\n<p>\n    Methods related to session handling:\n    <ul style=\"list-style-type: none;\">\n        <li><code>addSessionHandler(function, function_name)</code> Add your own function to the list of session handlers</li>\n        <li style=\"margin-bottom: 1em;\"><code>setSessionHandler(func_name_or_ordinal)</code> Tell <span class=\"nsr\">NSR</span> which of the available handlers to use (defaults to 0, 'memory_store').</li>\n        <li><code>getSession(request, callback)</code> Get the current <em>request.nsr_session</em>.</li>\n        <li><code>setSession(request, session_object, callback)</code> Set the current <em>request.nsr_session</em> with the provided session_object.</li>\n        <li><code>updateSession(request, session_object, callback)</code> Update the current <em>request.nsr_session</em> with the provided session_object, keeping not included keys and adding-updating keys present in session_object.</li>\n    </ul>\n    <div style=\"margin-top: 1em;\">\n        The three latter methods are convenience wrappers to access the low level method that handles <em>nsr_session</em>\n        which is responsible for the real implementation of the session mechanism.<br/>\n        The 3 are asynchronous, having the <em>nsr_session</em> returned as the only argument to the callback function.<br/>\n        Two low level handlers are provided built in: <em>memory_store</em> (default) and <em>text_store</em> (serializes each session to a file named by the session ID)<br/>\n        If you don't need/want to construct your own implementation, you don't need to know a thing\n        about it, but if you want to roll your own (for instance, if you want to save sessions to a database or a remote server)\n        here are a couple of things that you should keey in mind:\n    </div>\n    <div style=\"margin-top: 1em;\">\n      <span style=\"1em; padding-left: 3em;\">Function signature: <code>var db_store = function(request, opcode, sess_obj, callback);</code></span><br/>\n      <span style=\"1em; padding-left: 3em;\">Having a look at the source code used in <em>memory_store</em> and <em>text_store</em> should provide a fairly good idea of how things should work</span><br/>\n      <span style=\"1em; padding-left: 3em;\">In order to put your brand new session handler to work, you have to</span><br/>\n      <span style=\"1em; padding-left: 4em;\">1) Register it with <span class=\"nsr\">NSR</span> by means of <em>addSessionHandler</em></span><br/>\n      <span style=\"1em; padding-left: 4em;\">2) Put it to use with <em>setSessionHandler</em></span><br/>\n    </div>\n</p>\n\n<p>\n    You can see the session machinery in action in the <a href=\"http://node-simple-router.herokuapp.com/session\">Session Handling</a> section of the demo site.<br/>\n    By all means, review the code that makes it work in <em>test/server.js</em> or <em>test/server.coffee</em> if you are so inclined.\n</p>\n\n<div class=\"panel panel-primary\">\n    <div class=\"panel-heading\">\n        <h3 class=\"panel-title\">Utilities</h3>\n    </div>\n    <div class=\"panel-body\">\n        <p>\n            There are a bunch of utilities that can make your job easier, such as mk-server, the standalone tool\n            that will generate a <span class=\"nsr\">NSR</span> driven web server ready to go, cookie handling, uuid\n            generation, built-in async or promises (flow-control routines), but these are - rather, will be - fully commented in\n            <a target=\"_blank\" href=\"https://github.com/sandy98/node-simple-router/wiki/Utils\">utilities section of\n            NSR wiki</a>\n        </p>\n    </div>\n</div>\n\n### Real time\n\nBeginning with v0.9.0 NSR becomes real time. Now not only http requests routing is enabled, \nbut also the **ws** protocol (WebSockets) is implemented.\n\nSee all the juicy details at <a target=\"_blank\" href=\"https://github.com/sandy98/node-simple-router/wiki/WebSocket\">WebSocket section of\n            NSR wiki</a> or see it in action <a href=\"http://node-simple-router.herokuapp.com/sillychat.html\">at the demo site.</a>\n\n### Added goodies\n\nReally? Need more goodies?\n\nOk, here we go...\n -  **Default favicon** If your app doesn't have a favicon, <span class=\"nsr\">NSR</span> provides one for you. I _REALLY_ suggest you provide yours...\n -  **Default '404 - Not found' page.** Once again, you're advised to provide your own.\n -  **Default '500 - Server Error' page.** Same applies here.\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2012 Ernesto Savoretti <esavoretti@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "node-simple-router@0.9.1-1",
  "dist": {
    "shasum": "5a78b865fadd9c59efb8e91243d9883e878719dd"
  },
  "_from": "node-simple-router@*",
  "_resolved": "https://registry.npmjs.org/node-simple-router/-/node-simple-router-0.9.1-1.tgz"
}
